;; This buffer is for text that is not saved, and for Lisp evaluation.
;; To create a file, visit it with <open> and enter text in its buffer.

;; set to a bunch of locations in the scratch buffer
(defvar-local bulletins-mode-marks nil)
(setq bulletins-mode-marks (list (set-marker (make-marker) 1)
				 (set-marker (make-marker) 3)
				 (set-marker (make-marker) 7)
				 (set-marker (make-marker) 11)))
(setq m (nth 1 bulletins-mode-marks))
m
(< m 1)
nil
(< m 5)
t

(setq p (point))
(< m p)
t
(< p m)
nil

(seq-take-while #'(lambda (elem) (< elem 6)) bulletins-mode-marks)
(#<marker at 1 in *scratch*> #<marker at 3 in *scratch*>)


(defun previous-bulletin (pos)
  "Searches the bulletins-mode-marks list for the latest mark before 'pos'."
  (or (car (reverse (seq-take-while
		     #'(lambda (elem) (< elem pos))
		     bulletins-mode-marks)))
      nil) ;; or first bulletin? or point? if point, maybe decompose into a search function and a bindable function with this default
      ;; what if bulletins-mode-marks is empty?
  )

(defun goto-previous-bulletin ()
  (interactive)
  (let ((destination (previous-bulletin (point))))
    (if destination
	(goto-char destination)
        (message "No previous bulletin"))))

(previous-bulletin 3)
#<marker at 1 in *scratch*>
(previous-bulletin 2)
#<marker at 1 in *scratch*>
(previous-bulletin 1)
1
(previous-bulletin 4)
#<marker at 3 in *scratch*>
(previous-bulletin 5)
#<marker at 3 in *scratch*>
(previous-bulletin 6)
#<marker at 3 in *scratch*>
(previous-bulletin 7)
#<marker at 3 in *scratch*>
(previous-bulletin 8)
#<marker at 7 in *scratch*>
(previous-bulletin 10)
#<marker at 7 in *scratch*>
(previous-bulletin 11)
#<marker at 7 in *scratch*>
(previous-bulletin 12)
#<marker at 11 in *scratch*>
(previous-bulletin 999)
#<marker at 11 in *scratch*>



(defun next-bulletin (pos)
  "Searches the bulletins-mode-marks list for the first mark after 'pos'."
  (or (car (seq-drop-while #'(lambda (elem) (not (> elem pos))) bulletins-mode-marks))
      nil)
  )

(defun goto-next-bulletin ()
  "Jump to the next bulletin after point."
  ;; if there isn't one, just prints an error
  (interactive)
  (let ((destination (next-bulletin (point))))
    (if destination
	(goto-char destination)
        (message "No next bulletin"))))



(next-bulletin 1)
#<marker at 3 in *scratch*>
(next-bulletin 2)
#<marker at 3 in *scratch*>
(next-bulletin 3)
#<marker at 7 in *scratch*>
(next-bulletin 4)
#<marker at 7 in *scratch*>
(next-bulletin 5)
#<marker at 7 in *scratch*>
(next-bulletin 6)
#<marker at 7 in *scratch*>
(next-bulletin 7)
#<marker at 11 in *scratch*>
(next-bulletin 8)
#<marker at 11 in *scratch*>
(next-bulletin 9)
#<marker at 11 in *scratch*>
(next-bulletin 10)
#<marker at 11 in *scratch*>
(next-bulletin 11)
nil
(next-bulletin 12)
nil
